<!DOCTYPE html>

<html lang="en-US">
  <head>
    <meta charset="UTF-8" />

    <meta name="title" property="og:title" content="BridgeAPI" />

    <meta
      name="description"
      property="og:description"
      content="BridgeAPI is a serverless integration platform that
      lets you connect your apps through event-driven workflows"
    />

    <meta name="type" property="og:type" content="website" />

    <meta
      name="url"
      property="og:url"
      content="https://github.com/williampj/bridgeapi.js"
    />

    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta
      name="author"
      content="Andrew Crotwell, William Jackson, Angel Ruiz-Bates"
    />

    <title>BridgeAPI Case Study</title>

    <link
      href="https://fonts.googleapis.com/css?family=Roboto+Mono&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css?family=Roboto:400,500&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css?family=Lato&display=swap"
      rel="stylesheet"
    />

    <!-- <style>reset</style> -->

    <link rel="stylesheet" href="stylesheets/bootstrap.min.css" />
    <link rel="stylesheet" href="stylesheets/main.css" />

    <!-- <script></script> -->

    <script src="javascripts/main.js"></script>
  </head>

  <body class="d-flex">
    <div class="h-100">
      <!-- Cover -->
      <section
        class="d-flex w-100 mx-auto flex-column text-center text-white bg-dark"
      >
        <div class="wrapper">
          <div
            id="cover"
            class="d-flex flex-column justify-content-center page-main"
          >
            <img
              src="./images/logos/logo.svg"
              class="justify-self-center d-flex align-self-center mw-100"
            />
            <p class="lead d-flex align-self-center mt-5">
              BridgeAPI is a serverless integration platform that lets you
              connect your apps through event-driven workflows.
            </p>
          </div>
        </div>
      </section>
      <!-- End of Cover -->

      <!-- Section something -->
      <section class="text-center text-white">
        <div style="background-color: red">
          <h1 class="mb-0">Hello World</h1>
        </div>
      </section>
      <!-- End of Section something -->

      <!-- Section something -->
      <section class="text-center text-white">
        <div style="background-color: green">
          <h1 class="mb-0">Hello World</h1>
        </div>
      </section>
      <!-- End of Section something -->

      <!-- Section something -->
      <section class="text-center text-white">
        <div style="background-color: blue">
          <h1 class="mb-0">Hello World</h1>
        </div>
      </section>
      <!-- End of Section something -->

      <!-- Main Body -->
      <section id="main">
        <div class="container mt-4">
          <div class="row">
            <!-- TODO: Mobile size -->
            <div class="col-md-3">
              <nav id="case-study-nav" class="sticky-top top-200">
                <ul>
                  <li>
                    <a href="#introduction" class="case-study-anchor">
                      INTRODUCTION
                    </a>
                  </li>
                  <li>
                    <a href="#user-experience" class="case-study-anchor">
                      USER EXPERIENCE
                    </a>
                  </li>
                  <li>
                    <a href="#frontend-architecture" class="case-study-anchor">
                      FRONTEND ARCHITECTURE
                    </a>
                  </li>
                  <li>
                    <a href="#system-architecture" class="case-study-anchor">
                      SYSTEM ARCHITECTURE
                    </a>
                  </li>
                  <li>5</li>
                  <li>6</li>
                </ul>
              </nav>
            </div>
            <!-- CASE STUDY -->
            <div id="main-case-study" class="col-md-9 col-sm-12">
              <h1>Case Study</h1>
              <!-- 1. INTRODUCTION -->
              <section id="introduction">
                <h1 class="case-study-h1">1. Introduction</h1>
                <h2 class="case-study-h2">1.1 BridgeAPI</h2>
                <p>
                  BridgeAPI is a free, open source web developer tool that
                  receives, filters and forwards HTTP requests. This combination
                  allows developers to set up event-driven workflows in a few
                  simple steps with BridgeAPI as the bridge between apps.
                </p>

                <h2 class="case-study-h2">1.2 The API Economy</h2>
                <p>
                  Propelled by the rise in microservices, cloud computing,
                  Internet of Things, and the general benefits of integrating
                  diverse business applications, the API space has grown
                  exponentially since especially the mid 2000s. ProgrammableWeb,
                  a directory that lists public web-based APIs, documents a
                  growth of 2000 APIs yearly to more than 23,000 by 2019
                  (https://www.programmableweb.com/news/apis-show-faster-growth-rate-2019-previous-years/research/2019/07/17).
                  Postman, the most used developer API tool, registered a
                  ten-fold rise in API request folders, from 3.1 to 34.9 million
                  between 2017 and 2020
                  (https://blog.postman.com/api-growth-rate/). The integral role
                  API requests plays in the budding API economy demands tools
                  for developers to send, receive, monitor and chain API
                  requests.
                </p>

                <h2 class="case-study-h2">1.3 Current Tools</h2>
                <p>
                  Among developer tools used to send API requests, Postman is by
                  far the most utilized.
                </p>

                <img src="./images/postman.png" class="img-fluid mb-3" />

                <p>
                  It lets users select the request type and endpoint along with
                  a host of optional settings including parameters, headers and
                  body. It even allows for pre-request scripts whereby a request
                  can be delayed or more advanced features like regularly
                  scheduled requests. The response is subsequently rendered with
                  corresponding status, time, size and boy among other data.
                  Postman is very intuitive to use and practically covers every
                  conceivable aspect of an API request, yet it is limited in so
                  far that any workflow involving Postman must originate with a
                  Postman request, making it more useful as a testing tool for
                  an API interface. Any need to integrate workflows triggered by
                  webhooks will therefore require other tools.
                </p>

                <p>There are also practical tools to receive API requests.</p>

                <!-- <img src="./images/request-bin.png" class="img-fluid mb-3" /> -->

                <p>
                  Webhook.site is one such tool that provides a URL endpoint to
                  receive webhooks which can then be inspected upon reception.
                  Users can configure an automatic response that can be hard
                  coded or include data from the incoming request.
                </p>
                <p>
                  Lastly, there are apps that provide for workflows by providing
                  URL endpoints that, when pinged, trigger a user-defined
                  workflow. Zapier, IFTTT and Pipedream are examples within this
                  category.
                </p>

                <img src="./images/request-bin.png" class="img-fluid mb-3" />
                <img src="./images/zapier.png" class="img-fluid mb-3" />

                <p>
                  These fully-fledged sites are built to integrate large numbers
                  of predefined apps, which are selected with a click and the
                  granting of permission to access the external app from the
                  workflow site. With this access granted, any number of events
                  (in addition to webhooks) within the external app can trigger
                  the user-defined workflow. These sites are therefore popular
                  with retail users since the intricacies of API requests are
                  abstracted away. Furthermore, these sites are proprietary,
                  involving a limited free tier and scaled paid tiers.
                </p>

                <h2 class="case-study-h2">1.4 BridgeAPI Niche</h2>
                <p>
                  Within this mapping of the landscape of online API tools, a
                  gap seems to exist between the pure developer tools and the
                  retail workflow tools. We view BridgeAPI as an attempt to fill
                  the gap by being an open source developer tool to establish
                  workflows. It maintains the simplicity of the sending and the
                  receiving API developer tools, while combining the
                  functionality of both. Similarly to the developer tools,
                  BridgeAPI requests no permissions but trusts the user to
                  configure the endpoint, headers and body of an API request.
                  Yet as a functioning workflow tool, BridgeAPI can act as a
                  switchboard to monitor all API-driven one-step workflows
                  between two apps. It is this ambition which framed our UI as
                  we wanted to create an intuitive and simple tool, in
                  accordance with the KISS principle, that nonetheless contains
                  the features necessary to fulfill a developer’s workflow
                  needs.
                </p>
              </section>
              <!-- End of 1. INTRODUCTION -->

              <!-- 2. USER EXPERIENCE -->
              <section id="user-experience">
                <h1 class="case-study-h1">2. User Experience</h1>
                <h2 class="case-study-h2">2.1 Headers and settings</h2>
                <p>
                  The most critical part of the app is the configuration of the
                  workflow, which we refer to as a bridge. The ideal we strived
                  towards was that of a self-explanatory interface, where the
                  headings of each form and field would suffice in guiding the
                  user through the setup.
                </p>

                <img />

                <p>
                  In addition to providing a bridgeAPI endpoint, the Outbound
                  (forward) URL endpoint and Method dropdown constitute the
                  minimum viable settings for the workflow to function. While
                  any HTTP request can be selected, we set the default to POST
                  as we envision forwarding data in a request body as the most
                  frequent function of a bridge.
                </p>
                <p>
                  While the user can set any number of headers, BridgeAPI is
                  opinionated regarding the content type which is hard coded to
                  application/json. The following chart from programmableweb
                  between March 2018 and March 2020 shows the preponderance of
                  JSON and query strings as the standard data formats for API
                  requests, each accounting for more than ten times the number
                  of APIs accepting XML as the data format. We therefore chose
                  not to add XML support for the first iteration of BridgeAPI
                  given the added complexity required for what would be limited
                  use cases.
                </p>

                <img />

                <p>
                  Delays and retries are the two optional ‘extras’ in the bridge
                  configuration. A bridge allows for 0, 1, 3, and 5 retries,
                  which are triggered in case of unsuccessful response to an
                  outbound request. We define an unsuccessful request as any
                  request that is either incomplete or that completed but with a
                  response code equal to or greater than 300. While redirect
                  responses (300s) could be defined as successful, we chose to
                  define them as unsuccessful and thus trigger a retry to
                  account for temporary redirects, whereby a later attempt could
                  conceivably generate a response code in the 200s. The reason
                  we included this feature was to let the user set the
                  importance of successfully completing the outbound request, so
                  that 5 retries could be set for consequential bridges or in
                  cases where the receiving API is less reliable. (Visual idea:
                  code snippet for retries functionality).
                </p>
                <p>
                  In addition, users can decide between an instant forwarding of
                  the request or a delay of 15 minutes, 30 minutes, 1 hour, or 1
                  day. For certain workflows, we decided it would be logical to
                  insert a delay between links in a workflow chain. For example
                  if a user wanted to snooze all forwarding requests of a bridge
                  for a day, the 1 day delay option would ensure that all
                  incoming requests are received and held until the following
                  day. Another advantage is that it gives the user time to abort
                  or deactivate the bridge if circumstances during the delay
                  period call for it. (Visual idea: code snippet - Sidekiq delay
                  call).
                </p>
                <p>
                  When the delay and retry options are combined, the delay
                  between an unsuccessful request and subsequent retries will
                  grow exponentially as per the default logic in the Background
                  Job gem used (Sidekiq). We accept this default logic because
                  the user’s main concern will be the guaranteed delay between
                  the incoming webhook and the first forward request attempt,
                  while the delay between retries is of lesser importance.
                  (Visual idea - Sidekiq algorithm for retry intervals).
                </p>
                <p>
                  In order to include sensitive information in the body or
                  headers of an outbound request, we allow the user to store
                  environmental variables.
                </p>

                <img />

                <p>
                  Environmental variables are scoped to the bridge rather than
                  at the user level for a couple of reasons. Firstly, there is a
                  high likelihood of variable name collision at the user level
                  for repeating keys such as “password”. Secondly, by defining
                  and inspecting environmental variables on the same form where
                  they are applied, we can better adhere to our simple design
                  philosophy and goal of user friendliness by alleviating the
                  need to navigate to a configuration page to set or recollect
                  them. Finally, since they’re only expected to be set once per
                  bridge, we consider the inconvenience of duplicating
                  environmental variables across bridges with the same forward
                  endpoint to be insignificant.
                </p>
                <p>
                  To best protect the data, the values of an environmental
                  variable will be encrypted and filtered upon any save action
                  and cannot be viewed thereafter, leaving users with the option
                  of either referencing, deleting or editing it. For reasons of
                  brevity and familiarity, we selected “$env” as the name for
                  referencing the environmental variable namespace, which users
                  can do either from the header fields or in the payload. If a
                  JWT-secret key was stored as an environmental variable, it
                  would thus be accessible using the “$env.JWT-secret” syntax.
                </p>

                <img />

                <h2 class="case-study-h2">2.2 Payload</h2>
                <img />

                <p>
                  GET requests will be useful in cases where users are more
                  interested in assessing responses than in forwarding data. Yet
                  the majority of bridges are expected to be POST requests and
                  thus require a defined payload in the request body. We
                  contemplated two options for this feature, one of which was a
                  two-column table to be filled out with keys in the left and
                  values on the right. This approach would be complicated by
                  nested values that would require multiple dropdowns and soon
                  become unwieldy. We therefore chose a second option of
                  requiring a raw JSON payload since this delivers a cleaner and
                  more manageable interface. To aid the user, we set a default
                  payload to be edited or tested as is, along with a JSON
                  linter. The “$payload” syntax accesses the inbound request
                  payload, so in the above example “$payload.message” accesses a
                  “message” key at the highest level of the inbound request
                  payload, while “$payload.nested.message” plucks the value
                  referenced by the “message” key of the “nested” object. The
                  “$env'' syntax could likewise be applied to reference
                  environmental variables within the payload.
                </p>

                <h2 class="case-study-h2">
                  2.3 Actions - Abort, Activate/Deactivate, Delete
                </h2>
                <p>
                  In order to operate as a switchboard for event-driven
                  workflows, users need the option of configuring bridges after
                  saving and activating them. Defining and saving a bridge
                  automatically activates it, whereafter it listens for inbound
                  requests to its endpoint.
                </p>

                <img />

                <p>
                  Actions to the bridge are all collected within an “Actions”
                  modal one click away. We provide the option of deleting the
                  bridge entirely, toggling the active status (activate and
                  deactivate), or of aborting current ongoing requests in the
                  jobs queue - this will typically involve user-defined delays
                  or retries to the forward requests. This feature set is
                  simple, yet paired with its neighboring save button for
                  editing, it exhausts all predicted configuration needs of a
                  defined bridge.
                </p>
                <p>
                  With this single page, all the necessary fields are thus
                  provided to define a workflow between two apps. The interface
                  is simple, intuitive and focused on the necessary features,
                  with a couple of add-ons in the way of delays and retries that
                  provide useful options to the user without adding noteworthy
                  complexity.
                </p>
              </section>
              <!-- End of 2. USER EXPERIENCE -->

              <!-- 3. FRONTEND ARCHITECTURE -->
              <section id="frontend-architecture">
                <h1 class="case-study-h1">3. Frontend Architecture</h1>
                <h2 class="case-study-h2">3.1 NextJS</h2>
                <p>
                  Frontend frameworks have become an integral part of enterprise
                  web development. We selected NextJS as the optimal framework
                  for building out our React frontend because it leverages the
                  benefits of client-side rendered (CSR) apps, such as
                  responsiveness to user activity and decreased server load, as
                  well benefits of server-side rendered (SSR) such as as search
                  engine optimization (SEO) and fast initial page loads. Added
                  advantages include ease-of-use, comprehensive documentation
                  and an active community. Applying NextJS, our initial page
                  load is server-side rendered while assets and pre-rendered
                  HTML for linked pages are loaded on the client, offering users
                  the experience of a single-page app (SPA). [ Visual idea:
                  diagram showing initial page request and subsequent requests
                  of pre-rendered pages ]
                </p>

                <h2 class="case-study-h2">3.2 Payload Editor</h2>
                <p>
                  A crucial element of the app on the frontend is the
                  functionality and user-friendliness of the payload editor.
                  Since the editor should only support json, we had the option
                  of choosing a simple json editor for React such as
                  react-json-editor and react-json-view or more fully-featured,
                  multi-language-supporting editors such as CodeMirror, Ace and
                  Monaco. We decided to use an editor that offers multi-language
                  support so that the app could be expanded to other formats in
                  the future and provide a better IDE experience. We chose
                  CodeMirror, a text editor written in JavaScript for the
                  browser because it is battle-tested, contains the features we
                  sought, yet lighter weight than Ace and Monaco (which power
                  VSCode and Cloud9 respectively), which makes it a better fit
                  for our use cases of rendering multiple code editors on a
                  single page with different purposes. The react-codemirror2
                  wrapper for React lets us integrate it nicely as a React
                  component. [Visual idea: CodeMirror implementation code
                  snippet ]
                </p>

                <p>
                  The versatility of CodeMirror furthermore lets us set it as
                  read-only for inspecting past events and editable for
                  configuring a bridge, as well as interfacing it with a form
                  component when needed. Note that CodeMirror does not offer
                  support for Server Side Rendering (SSR), but as we employ
                  Client Side Rendering (CSR), we can retrieve editor state
                  asynchronously using React’s UseEffect hook in order to avoid
                  slowing down page loads. To improve the user experience, we
                  added a loading spinner that displays in place of each editor
                  until that editor is populated. [ Visual idea: loading spinner
                  ]
                </p>

                <p>
                  The end result is an intuitive editor with aids that users
                  have come to expect from editors like VSCode, including
                  full-screen mode for expansive payload editing, syntax
                  highlighting, json linting, auto-indent and active line
                  highlighter. [ Visual idea: gif of payload in action showing
                  syntax, linter, active line et al. ]
                </p>
              </section>
              <!-- End of 3. FRONTEND ARCHITECTURE -->

              <!-- 4. SYSTEM ARCHITECTURE -->
              <section id="system-architecture">
                <h1 class="case-study-h1">4. System Architecture</h1>
                <h2 class="case-study-h2">4.1 API Server</h2>
              </section>
            </div>
            <!-- End of CASE STUDY -->
          </div>
        </div>
      </section>
      <!-- End of Main Body -->

      <!-- Section Team -->
      <section class="text-center text-white">
        <div style="background-color: green">
          <h1 class="mb-0">Our Team</h1>
        </div>
      </section>
      <!-- End of Section Team -->

      <footer class="mt-auto text-white-50">
        <p class="mb-0" style="background-color: black">
          Cover template for
          <a href="https://getbootstrap.com/" class="text-white">Bootstrap</a>,
          by <a href="https://twitter.com/mdo" class="text-white">@mdo</a>.
        </p>
      </footer>
    </div>
  </body>
</html>
